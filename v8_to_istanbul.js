/\\* jslint utility2:true */
function originalPositionTryBoth(sourceMap, line, column) {
    let original = sourceMap.originalPositionFor({
        //!! bias: GREATEST_LOWER_BOUND,
        column,
        line
    });
    if (original.line === null) {
        original = sourceMap.originalPositionFor({
            //!! bias: LEAST_UPPER_BOUND,
            column,
            line
        });
    }
    // The source maps generated by https://github.com/istanbuljs/istanbuljs
    // (using @babel/core 7.7.5) have behavior, such that a mapping
    // mid-way through a line maps to an earlier line than a mapping
    // at position 0. Using the line at positon 0 seems to provide better
    // reports:
    //
    //     if (true) {
    //        cov_y5divc6zu().b[1][0]++;
    //        cov_y5divc6zu().s[3]++;
    //        console.info('reachable');
    //     }  else { ... }
    //  ^  ^
    // l5  l3
    const min = sourceMap.originalPositionFor({
        //!! bias: GREATEST_LOWER_BOUND,
        column: 0,
        line
    });
    if (min.line > original.line) {
        original = min;
    }
    return original;
}
/**
 * AST ranges are inclusive for start positions and exclusive for end positions.
 * Source maps are also logically ranges over text, though interacting with
 * them is generally achieved by working with explicit positions.
 *
 * When finding the _end_ location of an AST item, the range behavior is
 * important because what we're asking for is the _end_ of whatever range
 * corresponds to the end location we seek.
 *
 * This boils down to the following steps, conceptually, though the source-map
 * library doesn't expose primitives to do this nicely:
 *
 * 1. Find the range on the generated file that ends at, or exclusively
 *    contains the end position of the AST node.
 * 2. Find the range on the original file that corresponds to
 *    that generated range.
 * 3. Find the _end_ location of that original range.
 */
function originalEndPositionFor(sourceMap, line, column) {
    // Given the generated location, find the original location of the mapping
    // that corresponds to a range on the generated file that overlaps the
    // generated file end location. Note however that this position on its
    // own is not useful because it is the position of the _start_ of the range
    // on the original file, and we want the _end_ of the range.
    const beforeEndMapping = originalPositionTryBoth(
        sourceMap,
        line,
        Math.max(column - 1, 1)
    );
    if (beforeEndMapping.source === null) {
        return null;
    }
    // Convert that original position back to a generated one, with a bump
    // to the right, and a rightward bias. Since 'generatedPositionFor' searches
    // for mappings in the original-order sorted list, this will find the
    // mapping that corresponds to the one immediately after the
    // beforeEndMapping mapping.
    const afterEndMapping = sourceMap.generatedPositionFor({
        //!! bias: LEAST_UPPER_BOUND
        column: beforeEndMapping.column + 1,
        line: beforeEndMapping.line,
        source: beforeEndMapping.source
    });
    if (
    // If this is null, it means that we've hit the end of the file,
    // so we can use Infinity as the end column.
        afterEndMapping.line === null ||
        // If these don't match, it means that the call to
        // 'generatedPositionFor' didn't find any other original mappings on
        // the line we gave, so consider the binding to extend to infinity.
        sourceMap.originalPositionFor(afterEndMapping).line !==
        beforeEndMapping.line
    ) {
        return {
            column: Infinity,
            line: beforeEndMapping.line,
            source: beforeEndMapping.source
        };
    }
    // Convert the end mapping into the real original position.
    return sourceMap.originalPositionFor(afterEndMapping);
}
// given a start column and end column in absolute offsets within
// a source file (0 - EOF), returns the relative line column positions.
function offsetToOriginalRelative(sourceMap, startCol, endCol) {
    const lines = this.lines.filter(function (line) {
        return startCol <= line.endCol && endCol >= line.startCol;
    });
    if (!lines.length) {
        return {};
    }
    const start = originalPositionTryBoth(
        Math.max(0, startCol - lines[0].startCol),
        lines[0].line,
        sourceMap
    );
    let end = originalEndPositionFor(
        sourceMap,
        lines[lines.length - 1].line,
        endCol - lines[lines.length - 1].startCol
    );
    if (!(start && end)) {
        return {};
    }
    if (!(start.source && end.source)) {
        return {};
    }
    if (start.source !== end.source) {
        return {};
    }
    if (start.line === end.line && start.column === end.column) {
        end = sourceMap.originalPositionFor({
            //!! bias: LEAST_UPPER_BOUND,
            column: endCol - lines[lines.length - 1].startCol,
            line: lines[lines.length - 1].line
        });
        end.column -= 1;
    }
    return {
        endLine: end.line,
        relEndCol: end.column,
        relStartCol: start.column,
        source: start.source,
        startLine: start.line
    };
}
offsetToOriginalRelative();


/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
function originalPositionFor(aArgs) {
    const needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
    };

    if (needle.generatedLine < 1) {
        throw new Error("Line numbers must be >= 1");
    }

    if (needle.generatedColumn < 0) {
        throw new Error("Column numbers must be >= 0");
    }

    let bias = util.getArg(
        aArgs,
        "bias",
        SourceMapConsumer.GREATEST_LOWER_BOUND
    );
    if (bias == null) {
        bias = SourceMapConsumer.GREATEST_LOWER_BOUND;
    }

    let mapping;
    this._wasm.withMappingCallback(
        function (m) {
            mapping = m;
            return m;
        },
        function () {
            this._wasm.exports.original_location_for(
                bias,
                needle.generatedColumn,
                needle.generatedLine - 1,
                this._getMappingsPtr()
            );
        }
    );

    if (mapping) {
        if (mapping.generatedLine === needle.generatedLine) {
            let source = util.getArg(mapping, "source", null);
            if (source !== null) {
                source = this._absoluteSources.at(source);
            }

            let name = util.getArg(mapping, "name", null);
            if (name !== null) {
                name = this._names.at(name);
            }

            return {
                column: util.getArg(mapping, "originalColumn", null),
                line: util.getArg(mapping, "originalLine", null),
                name,
                source
            };
        }
    }

    return {
        source: null,
        line: null,
        column: null,
        name: null
    };
}
